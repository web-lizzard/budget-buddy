import uuid
from abc import ABC, abstractmethod
from typing import TypedDict

from adapters.outbound.persistence.sql_alchemy.models import UserModel
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from application.security import get_password_hash, verify_password
from application.services.unauthorized_user_error import UnauthorizedUserError
from application.services.user_already_exists_error import UserAlreadyExistsError
from application.services.user_not_found_error import UserNotFoundError


# Using TypedDict for user data structure for now,
# can be replaced with a Pydantic model if more complex validation/serialization is needed.
class UserData(TypedDict):
    id: str
    email: str
    # Potentially other fields like is_active, is_superuser etc.


class UserService(ABC):
    @abstractmethod
    async def create_user(self, email: str, password: str) -> None:
        """
        Create a new user with the specified email and password.

        Args:
            email (str): The email of the user to be created.
            password (str): The password for the new user.

        Raises:
            UserAlreadyExistsError: If a user with the given email already exists.
        """
        pass

    @abstractmethod
    async def authenticate_user(self, email: str, password: str) -> UserData:
        """
        Authenticate a user by verifying their email and password.

        Args:
            email (str): The email of the user to authenticate.
            password (str): The password of the user.

        Returns:
            UserData: The authenticated user's data.

        Raises:
            UserNotFoundError: If no user is found with the given email.
            UnauthorizedUserError: If the password is incorrect.
        """
        pass

    @abstractmethod
    async def get_user_by_id(self, user_id: str) -> UserData:
        """
        Retrieve a user's data by their unique user ID.

        Args:
            user_id (str): The unique identifier of the user.

        Returns:
            UserData: The user's data.

        Raises:
            UserNotFoundError: If no user is found with the given ID.
        """
        pass


class SQLAlchemyUserService(UserService):
    def __init__(self, session: AsyncSession):
        self.session = session

    async def create_user(self, email: str, password: str) -> None:
        """
        Creates a new user in the database.
        Checks for email uniqueness.
        Hashes the password before storage.
        """
        stmt = select(UserModel).where(UserModel.email == email)
        result = await self.session.execute(stmt)
        existing_user = result.scalars().first()

        if existing_user:
            raise UserAlreadyExistsError(email)

        hashed_password = await get_password_hash(password)

        # Create new UserModel instance
        new_user = UserModel(
            # id will be generated by default by UUID(as_uuid=True), default=uuid.uuid4
            email=email,
            hashed_password=hashed_password,
        )

        self.session.add(new_user)
        try:
            await self.session.commit()
            await self.session.refresh(
                new_user
            )  # To get the generated ID and other defaults

        except Exception as e:  # Catch potential DB errors
            await self.session.rollback()
            print(f"Error creating user in DB: {e}")
            raise e

    async def authenticate_user(self, email: str, password: str) -> UserData:
        """
        Authenticates a user against the database.
        Fetches a user by email and verifies the password.
        """
        stmt = select(UserModel).where(UserModel.email == email)
        result = await self.session.execute(stmt)
        user = result.scalars().first()

        if not user:
            raise UnauthorizedUserError(email)

        if not await verify_password(password, user.hashed_password):
            raise UnauthorizedUserError(email)

        return UserData(id=str(user.id), email=user.email)

    async def get_user_by_id(self, user_id: str) -> UserData:
        """
        Fetches a user by their ID from the database.
        """
        try:
            user_uuid = uuid.UUID(user_id)  # Convert string ID to UUID for DB query
        except ValueError as exc:
            raise UnauthorizedUserError(user_id) from exc

        stmt = select(UserModel).where(UserModel.id == user_uuid)
        result = await self.session.execute(stmt)
        user = result.scalars().first()

        if not user:
            raise UserNotFoundError(user_id)

        return UserData(id=str(user.id), email=user.email)
