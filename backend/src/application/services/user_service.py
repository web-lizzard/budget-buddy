import uuid
from abc import ABC, abstractmethod
from typing import TypedDict

from adapters.outbound.persistence.sql_alchemy.models import UserModel
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from application.exceptions import (
    UnauthorizedUserError,
    UserAlreadyExistsError,
    UserNotFoundError,
)
from application.services.security_service import SecurityService


# Using TypedDict for user data structure for now,
# can be replaced with a Pydantic model if more complex validation/serialization is needed.
class UserData(TypedDict):
    id: str
    email: str
    # Potentially other fields like is_active, is_superuser etc.


class UserService(ABC):
    @abstractmethod
    async def create_user(self, email: str, password: str) -> UserData:
        """
        Create a new user with the specified email and password.

        Args:
            email (str): The email of the user to be created.
            password (str): The password for the new user.

        Raises:
            UserAlreadyExistsError: If a user with the given email already exists.
        """
        pass

    @abstractmethod
    async def authenticate_user(self, email: str, password: str) -> UserData:
        """
        Authenticate a user by verifying their email and password.

        Args:
            email (str): The email of the user to authenticate.
            password (str): The password of the user.

        Returns:
            UserData: The authenticated user's data.

        Raises:
            UserNotFoundError: If no user is found with the given email.
            UnauthorizedUserError: If the password is incorrect.
        """
        pass

    @abstractmethod
    async def get_user_by_id(self, user_id: str) -> UserData:
        """
        Retrieve a user's data by their unique user ID.

        Args:
            user_id (str): The unique identifier of the user.

        Returns:
            UserData: The user's data.

        Raises:
            UserNotFoundError: If no user is found with the given ID.
        """
        pass


class SQLAlchemyUserService(UserService):
    def __init__(self, session: AsyncSession, security_service: SecurityService):
        self._session = session
        self._security_service = security_service

    async def create_user(self, email: str, password: str) -> UserData:
        """
        Creates a new user in the database.
        Checks for email uniqueness.
        Hashes the password before storage.
        """
        stmt = select(UserModel).where(UserModel.email == email)
        result = await self._session.execute(stmt)
        existing_user = result.scalars().first()

        if existing_user:
            raise UserAlreadyExistsError(email)

        hashed_password = await self._security_service.get_password_hash(password)

        # Create new UserModel instance
        new_user = UserModel(
            # id will be generated by default by UUID(as_uuid=True), default=uuid.uuid4
            email=email,
            hashed_password=hashed_password,
        )

        self._session.add(new_user)
        try:
            await self._session.commit()
            await self._session.refresh(
                new_user
            )  # To get the generated ID and other defaults
            return UserData(id=str(new_user.id), email=new_user.email)

        except Exception as e:  # Catch potential DB errors
            await self._session.rollback()
            print(f"Error creating user in DB: {e}")
            raise e

    async def authenticate_user(self, email: str, password: str) -> UserData:
        """
        Authenticates a user against the database.
        Fetches a user by email and verifies the password.
        """
        stmt = select(UserModel).where(UserModel.email == email)
        result = await self._session.execute(stmt)
        user = result.scalars().first()

        if not user:
            raise UnauthorizedUserError(email)

        if not await self._security_service.verify_password(
            password, user.hashed_password
        ):
            raise UnauthorizedUserError(email)

        return UserData(id=str(user.id), email=user.email)

    async def get_user_by_id(self, user_id: str) -> UserData:
        """
        Fetches a user by their ID from the database.
        """
        try:
            user_uuid = uuid.UUID(user_id)  # Convert string ID to UUID for DB query
        except ValueError as exc:
            raise UnauthorizedUserError(user_id) from exc

        stmt = select(UserModel).where(UserModel.id == user_uuid)
        result = await self._session.execute(stmt)
        user = result.scalars().first()

        if not user:
            raise UserNotFoundError(user_id)

        return UserData(id=str(user.id), email=user.email)
